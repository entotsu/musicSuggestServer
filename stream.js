// Generated by CoffeeScript 1.7.1
(function() {
  var DEFAULT_LIMIT_OF_TOP_TRACK, DELAY_OF_START_MAIN_LOOP, FIRST_ARTIST_LIMIT, FIRST_REQUEST_DELAY, FIRST_TRACK_LIMIT, NG_WORDS, Stream, YTParser, addTracksLoopInterval, addVideoLoopInterval, clog, moment, randomPick, req,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  clog = function(s) {
    return console.log(s);
  };

  clog("stream.coffee");

  req = require('./request.js');

  moment = require("moment");

  YTParser = require('./getYouTubeURL.js');

  FIRST_REQUEST_DELAY = 5000;

  FIRST_ARTIST_LIMIT = 4;

  FIRST_TRACK_LIMIT = 2;

  DELAY_OF_START_MAIN_LOOP = 50;

  addTracksLoopInterval = function(tracks_num) {
    var delay;
    delay = tracks_num * tracks_num + 200;
    clog(" ... + wait " + delay + "msec");
    return delay;
  };

  addVideoLoopInterval = function(playlist_length) {
    var delay;
    delay = playlist_length * playlist_length / 5 + 100;
    clog(" ... # wait " + delay + "msec");
    return delay;
  };

  DEFAULT_LIMIT_OF_TOP_TRACK = 25;

  NG_WORDS = ["歌ってみ", "うたってみ", "カラオケ", "ｶﾗｵｹ", "カバー", "ｶﾊﾞｰ", "cover", "Cover", "COVER", "コピー", "ｺﾋﾟｰ", "copy", "Copy", "COPY", "ピッチ", "弾いてみ", "ひいてみ", "メドレー", "ﾒﾄﾞﾚｰ", "BGM", "作業用", "Trailer", "トレーラー", "寄せ集め", "集めてみた", "弾き語り", "弾きかたり", "ひきかたり", "Short ver"];

  Stream = (function() {
    function Stream(artistName, artistId) {
      var self;
      this.artistName = artistName;
      this.artistId = artistId;
      this.addVideoLoop = __bind(this.addVideoLoop, this);
      this.addTracksLoop = __bind(this.addTracksLoop, this);
      self = this;
      this.uncheckedTracks = [];
      this.uncheckedVideos = [];
      this.playlist = [];
      this.similarArtists = [];
      this.id = "s" + moment().unix().toString();
      this.sendNum = 0;
      this.isStartAddTracksLoop = false;
      this.isStartAddVideosLoop = false;
      self.startStream();
      this.firstRequestDelay = FIRST_REQUEST_DELAY;
      this.tracksLoopTimer = null;
      this.videoLoopTimer = null;
      this.isExhaustedArtists = false;
      this.isStop = false;
      this.timeoutTimer = null;
    }

    Stream.prototype.popTracks = function(num) {
      var sendTraks;
      sendTraks = null;
      if (!num || num <= 0) {
        sendTraks = this.playlist.splice(0);
      } else {
        sendTraks = this.playlist.splice(this.playlist.length - num, num);
      }
      this.sendNum += sendTraks.length;
      clog("" + this.id + " s" + this.sendNum + " p" + this.playlist.length + " t" + this.uncheckedTracks.length + " -> pop " + sendTraks.length + " tracks");
      return sendTraks;
    };

    Stream.prototype.stop = function() {
      clog("stop stream");
      this.isStop = true;
      clearTimeout(this.tracksLoopTimer);
      return clearTimeout(this.videoLoopTimer);
    };

    Stream.prototype.startStream = function() {
      clog("##### startStream #####");
      this.generateFastPlaylist();
      return setTimeout(((function(_this) {
        return function() {
          return _this.addArtists(999, function() {
            _this.addTracksLoop();
            return _this.addVideoLoop();
          });
        };
      })(this)), DELAY_OF_START_MAIN_LOOP);
    };

    Stream.prototype.generateFastPlaylist = function() {
      var al, tl;
      al = FIRST_ARTIST_LIMIT;
      tl = FIRST_TRACK_LIMIT;
      return this.addArtists(al, (function(_this) {
        return function() {
          var i, _i, _results;
          _results = [];
          for (i = _i = 0; 0 <= al ? _i < al : _i > al; i = 0 <= al ? ++_i : --_i) {
            _results.push(_this.addTracks(tl, function() {
              var j, _j, _results1;
              _results1 = [];
              for (j = _j = 0; 0 <= tl ? _j < tl : _j > tl; j = 0 <= tl ? ++_j : --_j) {
                _results1.push(_this.addVideo());
              }
              return _results1;
            }));
          }
          return _results;
        };
      })(this));
    };

    Stream.prototype.addTracksLoop = function() {
      if (!this.isStop) {
        if (this.similarArtists.length === 0) {
          clog("similarArtists is end.");
          return this.isExhaustedArtists = true;
        } else {
          this.tracksLoopTimer = setTimeout(this.addTracksLoop, addTracksLoopInterval(this.uncheckedTracks.length));
          return this.addTracks(DEFAULT_LIMIT_OF_TOP_TRACK);
        }
      }
    };

    Stream.prototype.addVideoLoop = function() {
      if (!this.isStop) {
        if (this.uncheckedTracks.length === 0) {
          if (!this.isExhaustedArtists) {
            return setTimeout(this.addVideoLoop, 1000);
          }
        } else {
          this.videoLoopTimer = setTimeout(this.addVideoLoop, addVideoLoopInterval(this.playlist.length));
          return this.addVideo();
        }
      }
    };

    Stream.prototype.addArtists = function(limit, callback) {
      return req.getSimilarArtist(this.artistName, this.artistId, limit, (function(_this) {
        return function(artists) {
          var a, newArtist, _i, _len;
          if (!artists) {
            console.error("artists is undifined!");
            process.exit();
          } else {
            for (_i = 0, _len = artists.length; _i < _len; _i++) {
              a = artists[_i];
              newArtist = {};
              newArtist.name = a.name;
              newArtist.id = a.mbid;
              clog(newArtist.name);
              _this.similarArtists.push(newArtist);
            }
            clog("+++++++++++++++++ " + _this.similarArtists.length + " artists is added!");
          }
          if (callback) {
            return callback();
          }
        };
      })(this));
    };

    Stream.prototype.addTracks = function(limit, callback) {
      var artist;
      artist = randomPick(this.similarArtists);
      return req.getTopTrack(artist.name, artist.mbid, limit, (function(_this) {
        return function(tracks) {
          var aTrack, newTrackList, t, _i, _len;
          if (!tracks) {
            console.error("tracks is undifined!");
            return process.exit();
          } else {
            newTrackList = [];
            for (_i = 0, _len = tracks.length; _i < _len; _i++) {
              t = tracks[_i];
              aTrack = {};
              aTrack.artist_name = t.artist.name;
              aTrack.track_name = t.name;
              if (t.image && t.image[0]) {
                aTrack.image_url = t.image[0]['#text'];
              }
              newTrackList.push(aTrack);
            }
            _this.uncheckedTracks = _this.uncheckedTracks.concat(newTrackList);
            clog("" + _this.id + " s" + _this.sendNum + " p" + _this.playlist.length + " t" + _this.uncheckedTracks.length + "  + " + tracks.length + " tracks +++++++++++++++++++");
            if (callback) {
              return callback();
            }
          }
        };
      })(this));
    };

    Stream.prototype.addVideo = function() {
      var keyword, track;
      track = randomPick(this.uncheckedTracks);
      if (track) {
        keyword = track.artist_name + " " + track.track_name;
        return req.searchVideo(keyword, 1, (function(_this) {
          return function(videos) {
            var id, ng_word, title, video, _i, _len;
            video = videos[0];
            if (!video) {
              return console.error("video is undifined!!!!");
            } else {
              title = video.snippet.title;
              id = video.id.videoId;
              if (title.indexOf(track.artist_name) === -1) {
                return false;
              }
              if (title.indexOf(track.track_name) === -1) {
                return false;
              }
              for (_i = 0, _len = NG_WORDS.length; _i < _len; _i++) {
                ng_word = NG_WORDS[_i];
                if (title.indexOf(ng_word) !== -1) {
                  clog("### BLOCK by NG WORD " + title + " " + ng_word);
                  return false;
                }
              }
              return YTParser.getUrlFromId(id, function(videoURL) {
                if (videoURL) {
                  if (videoURL !== "undefined&signature=undefined") {
                    track.url = videoURL;
                    track.youtube_id = id;
                    _this.playlist.push(track);
                    return clog(("" + _this.id + " s" + _this.sendNum + " p" + _this.playlist.length + " t" + _this.uncheckedTracks.length + "  # added!　　") + id + "  " + title);
                  }
                }
              });
            }
          };
        })(this));
      }
    };

    Stream.prototype.playTest = function() {
      return clog("playTest");
    };

    return Stream;

  })();

  randomPick = function(ary) {
    var randIndex;
    randIndex = Math.floor(ary.length * Math.random());
    return ary.splice(randIndex, 1)[0];
  };

  module.exports = Stream;

}).call(this);
